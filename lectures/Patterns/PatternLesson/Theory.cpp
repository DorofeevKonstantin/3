/*
* 23.12.22 Ваш покорный слуга КБ, Федрушков Денис.
* 
* Source: Gang of Four. Design Patterns.
* Паттерны:
* 
* Порождающие паттерны: (Создание объектов, Абстрагирование интерфейсов их создания, итд)
*  
* 1) Singleton (Одиночка) Singleton.cpp
* 
* Шаблон хранящий единственный объект и предостовляющий глобальную точку доступа к нему.
* 
* 2) Buider (Строитель) PizzaBuilder.h
* 
* Шаблон позволяющий отделить построение объектов в отдельный класс.
* 
* 3) Abstract Factory (Абстрактная Фабрика) AbstractFactory.hpp
* 
* Шаблон предоставляющий единый интерфейс создания объектов,
* но оставляющий право выбора конкретного объекта дочерним классам.
* 
* 4) Prototype (Прототип) Pizza.h (60-64)
* 
* Шаблон позволяющий создавать объекты на основе существующих путём клонирования.
* 
* Структурные: (Построение общей архитектуры программы и организации зависимостей между объектами.)
* 1) Adapter/Wrapper (Адаптер/Обёртка) Adapter.cpp
* 
* Шаблон позволяющий адаптировать одни интерфейсы под другие.
* 
* 2) Decorator (Декоратор) Decorator.cpp
* Шаблон позволяющий добавить/изменить функциональность объекта не трогая его реализацию.
* 
* 3) Facade (Фасад) Facade.cpp
* Шаблон предоставляющий единую "точку входа" ко всей архитектуре проекта.
* 
* 4) Flyweight* (Приспособленец/Легковес)
* 
* Шаблон представляющий объект как цельный, но в реальности являющийся ссылкой/"внешним видом" объекта с похожей структурой.
* 
* Поведенческие (определяют взаимодействие между объектами, увеличивая таким образом их гибкость и гибкость программы.):
* 1) Strategy (Стратегия)
* 
* Шаблон позволяющий инкапсулировать одни алгоритмы, и параметризировать/динамически изменять их поведение.
*
* 2) NullObject NullPizza.h 
* 
* Объект выдающий себя за полноценный, но на деле являющийся пустышкой.
* 
* 
* Monad (Порождающий&Поведенческий) Monad.cpp
* Шаблон позволяющий превращать одни типы данных в другие.
* 
* 
* 
* 
* 
* 
* 
* 
* 
* SOLID
* S - Single Responsobility (Принцип Единственной Ответственности)
* Сущности в коде будь то функции->классы->модули должны выполнять конкретную одну задачу соответствующую своим размерам.
* 
* O - Open/Closed (Принцип открытости/закрытости)
* Программные интерфейсы должны быть открыты для дополнения ими, но закрыты для модификации.
* 
* L - Liskov Substitute (Принцип Подстановки Лисков)
* Объекты базовых классов должны без проблем заменять объекты дочерних без изменения поведения программы.
* (То что имеет желтый цвет, плавает и крякает как утка должно вести себя как утка.)
* 
* I - Interface Segregation (Принцип отделения/разделения интерфейсов)
* 
* Интерфейсы не должны быть месивом всех возможностей, они должны соответствовать S.
* 
* D - Dependency Inversion (Принцип инверсии зависимостей)
* 
* Конкретные реализации должны зависеть от абстрактных классов, а не наоборот.
*/
